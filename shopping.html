<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Shopping Lists</title>
    <link rel="stylesheet" href="css/styles.css">
    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <nav class="nav-buttons">
                <a href="settings.html" class="nav-button" title="Settings">⚙️</a>
                <a href="index.html" class="nav-button">Reminders</a>
                <a href="shopping.html" class="nav-button active">Shopping</a>
                <a href="travel.html" class="nav-button">Travel</a>
                <a href="calendar.html" class="nav-button">Calendar</a>
            </nav>
        </header>
        <div class="add-list-group">
            <input type="text" id="add-list-input" class="add-list-input" placeholder="New list name...">
            <button id="add-list-btn" class="add-list-btn">Add List</button>
        </div>
        <div id="lists-container" class="lists-container"></div>
    </div>
    <!-- Supabase SDK -->
    <script type="module">
        // Import Supabase client and configuration
        import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
        import { supabaseConfig } from './js/config.js';

        // Initialize Supabase client with proper headers
        const supabase = createClient(
          supabaseConfig.supabaseUrl,
          supabaseConfig.supabaseKey,
          {
            db: {
              schema: 'public',
            },
            auth: {
              autoRefreshToken: true,
              persistSession: true,
              detectSessionInUrl: true
            },
            global: {
              headers: {
                'Content-Type': 'application/json',
                'apikey': supabaseConfig.supabaseKey,
                'Authorization': `Bearer ${supabaseConfig.supabaseKey}`
              }
            }
          }
        );

        // In-memory list storage for immediate UI updates
        let listsData = [];

        function showError(msg) {
            let errDiv = document.getElementById('error-msg');
            if (!errDiv) {
                errDiv = document.createElement('div');
                errDiv.id = 'error-msg';
                errDiv.style.color = '#ff6b6b';
                errDiv.style.textAlign = 'center';
                errDiv.style.marginBottom = '16px';
                document.querySelector('.app-container').insertBefore(errDiv, document.querySelector('.add-list-group'));
            }
            errDiv.textContent = msg;
        }

        // Generate unique ID for new lists
        function generateListId() {
            return 'shopping_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Debounce utility to avoid too frequent saves
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Comprehensive cleanup function to remove all drag-over styling
        function cleanupAllDragStyling() {
            // Remove drag-over from all elements that might have it
            const allDragOverElements = document.querySelectorAll('.drag-over');
            allDragOverElements.forEach(element => {
                element.classList.remove('drag-over');
            });
            
            // Also remove dragging class from any elements that might still have it
            const allDraggingElements = document.querySelectorAll('.dragging');
            allDraggingElements.forEach(element => {
                element.classList.remove('dragging');
            });
            
            console.log('Cleaned up all drag styling');
        }

        // Helper function to update list data indexes after DOM reordering
        function updateListDataIndexes() {
            const listElements = document.querySelectorAll('.list');
            const newOrderedLists = [];
            listElements.forEach(listElement => {
                const listId = listElement.dataset.listId;
                const list = listsData.find(l => l.id === listId);
                if (list) {
                    newOrderedLists.push(list);
                }
            });
            listsData = newOrderedLists;
        }

        // Helper function to update entry data indexes after DOM reordering
        function updateEntryDataIndexes(listElement, list) {
            const entryElements = listElement.querySelectorAll('li[data-entry-index]');
            const newOrderedEntries = [];
            
            // Build new entries array based on DOM order and actual input values
            entryElements.forEach((entryElement, newIndex) => {
                const entryInput = entryElement.querySelector('.entry-input');
                const entryCheckbox = entryElement.querySelector('.entry-checkbox');
                if (entryInput) {
                    // Use the actual current text value from the input and checkbox state
                    newOrderedEntries.push({
                        text: entryInput.value,
                        checked: entryCheckbox ? entryCheckbox.checked : false
                    });
                    // Update the element's index to match its new position
                    entryElement.dataset.entryIndex = newIndex;
                }
            });
            
            // Replace the list's entries with the reordered data
            list.entries = newOrderedEntries;
            console.log('Updated entry data for list', list.id, ':', newOrderedEntries);
        }

        // Reorder lists function - now with DOM manipulation only
        async function reorderLists(draggedListId, targetListId) {
            try {
                const listsContainer = document.getElementById('lists-container');
                const draggedElement = document.querySelector(`[data-list-id="${draggedListId}"]`);
                const targetElement = document.querySelector(`[data-list-id="${targetListId}"]`);
                
                if (!draggedElement || !targetElement || draggedListId === targetListId) return;

                console.log(`Reordering lists: moving ${draggedListId} relative to ${targetListId}`);

                // Get current positions to determine drag direction
                const allListElements = Array.from(listsContainer.children);
                const draggedIndex = allListElements.indexOf(draggedElement);
                const targetIndex = allListElements.indexOf(targetElement);

                console.log(`Current positions - dragged: ${draggedIndex}, target: ${targetIndex}`);

                // Perform DOM reordering immediately based on drag direction
                if (draggedIndex < targetIndex) {
                    // Dragging down: insert after target
                    const targetNext = targetElement.nextSibling;
                    if (targetNext) {
                        listsContainer.insertBefore(draggedElement, targetNext);
                    } else {
                        listsContainer.appendChild(draggedElement);
                    }
                } else {
                    // Dragging up: insert before target
                    listsContainer.insertBefore(draggedElement, targetElement);
                }

                // Update our in-memory data to match the new DOM order
                updateListDataIndexes();

                console.log('Lists reordered in DOM and data updated');

                // Save to database in background (no UI updates)
                const updatePromises = listsData.map(async (list, index) => {
                    const { error } = await supabase
                        .from('shopping_lists')
                        .update({ 
                            list_order: index,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', list.id);
                    
                    if (error) {
                        console.error(`Error updating order for list ${list.id}:`, error);
                        return false;
                    }
                    return true;
                });
                
                const results = await Promise.all(updatePromises);
                const allSuccessful = results.every(result => result === true);
                
                if (allSuccessful) {
                    console.log('Lists reordered and saved successfully to database');
                } else {
                    console.error('Some lists failed to update order');
                    showError('Failed to save new list order');
                }
            } catch (err) {
                console.error('Error reordering lists:', err);
                showError('Error reordering lists: ' + err.message);
            }
        }

        // Reorder entries within a list - now with DOM manipulation only
        async function reorderEntries(listElement, list, draggedEntryIdx, targetEntryIdx) {
            console.log('reorderEntries called. List:', list.id, 'Source Idx:', draggedEntryIdx, 'Target Idx:', targetEntryIdx);
            try {
                if (draggedEntryIdx !== targetEntryIdx) {
                    const ul = listElement.querySelector('ul');
                    const draggedLi = ul.children[draggedEntryIdx];
                    const targetLi = ul.children[targetEntryIdx];
                    
                    if (!draggedLi || !targetLi) return;

                    // Perform DOM reordering immediately
                    if (draggedEntryIdx < targetEntryIdx) {
                        // Moving down: insert after target
                        const targetNext = targetLi.nextSibling;
                        if (targetNext) {
                            ul.insertBefore(draggedLi, targetNext);
                        } else {
                            ul.appendChild(draggedLi);
                        }
                    } else {
                        // Moving up: insert before target
                        ul.insertBefore(draggedLi, targetLi);
                    }

                    // Update entry data indexes to match new DOM order
                    updateEntryDataIndexes(listElement, list);

                    // Save the updated list in background
                    await saveList(list);
                    
                    console.log('Entries reordered successfully');
                }
            } catch (err) {
                console.error('Error reordering entries:', err);
                showError('Error reordering entries: ' + err.message);
            }
        }

        // Move entry between different lists - now with DOM manipulation only
        async function moveEntryBetweenLists(sourceListId, sourceEntryIdx, targetListId, targetEntryIdx) {
            console.log(`moveEntryBetweenLists called. From list ${sourceListId} (idx ${sourceEntryIdx}) to list ${targetListId} (idx ${targetEntryIdx})`);
            try {
                const sourceList = listsData.find(list => list.id === sourceListId);
                const targetList = listsData.find(list => list.id === targetListId);
                
                if (!sourceList || !targetList) {
                    console.error('Source or target list not found');
                    return;
                }

                const sourceListElement = document.querySelector(`[data-list-id="${sourceListId}"]`);
                const targetListElement = document.querySelector(`[data-list-id="${targetListId}"]`);
                const sourceUl = sourceListElement.querySelector('ul');
                const targetUl = targetListElement.querySelector('ul');
                
                const draggedLi = sourceUl.children[sourceEntryIdx];
                if (!draggedLi) return;

                // Get the actual text value and checked state from the dragged entry before removing it
                const draggedEntryInput = draggedLi.querySelector('.entry-input');
                const draggedEntryCheckbox = draggedLi.querySelector('.entry-checkbox');
                const movedEntryText = draggedEntryInput ? draggedEntryInput.value : '';
                const movedEntryChecked = draggedEntryCheckbox ? draggedEntryCheckbox.checked : false;

                console.log('Moving entry text:', movedEntryText, 'Checked:', movedEntryChecked);

                // Remove from DOM first
                draggedLi.remove();

                // Create new DOM element for target list with the correct text and checked state
                const newLi = createEntryElement(targetList, { text: movedEntryText, checked: movedEntryChecked }, targetEntryIdx);
                
                // Insert at correct position in target DOM
                if (targetEntryIdx >= targetUl.children.length) {
                    targetUl.appendChild(newLi);
                } else {
                    targetUl.insertBefore(newLi, targetUl.children[targetEntryIdx]);
                }

                // Update both lists' data based on current DOM state
                updateEntryDataIndexes(sourceListElement, sourceList);
                updateEntryDataIndexes(targetListElement, targetList);

                // Save both lists in background
                const savePromises = [saveList(sourceList), saveList(targetList)];
                const results = await Promise.all(savePromises);
                
                if (results.every(result => result === true)) {
                    console.log(`Entry "${movedEntryText}" moved from list ${sourceListId} to ${targetListId}`);
                } else {
                    console.error('Failed to save one or both lists after moving entry');
                    showError('Failed to move entry between lists');
                }
            } catch (err) {
                console.error('Error moving entry between lists:', err);
                showError('Error moving entry between lists: ' + err.message);
            }
        }

        // Create a single entry element (for optimistic UI updates)
        function createEntryElement(list, entry, entryIdx) {
            const li = document.createElement('li');
            
            // Add drag handle for entries
            const entryDragHandle = document.createElement('span');
            entryDragHandle.className = 'drag-handle';
            entryDragHandle.innerHTML = '⋮⋮';
            entryDragHandle.title = 'Drag to reorder entries';
            entryDragHandle.style.fontSize = '12px';
            
            // Add checkbox for shopping items
            const entryCheckbox = document.createElement('input');
            entryCheckbox.type = 'checkbox';
            entryCheckbox.className = 'entry-checkbox';
            entryCheckbox.checked = entry.checked || false;
            
            const entryInput = document.createElement('input');
            entryInput.type = 'text';
            entryInput.value = entry.text || entry;
            entryInput.className = 'entry-input';
            if (entry.checked) {
                entryInput.classList.add('checked');
            }
            
            // Update input styling when checkbox changes
            entryCheckbox.onchange = () => {
                if (entryCheckbox.checked) {
                    entryInput.classList.add('checked');
                } else {
                    entryInput.classList.remove('checked');
                }
                
                // Save the updated checked state
                const currentIndex = parseInt(li.dataset.entryIndex);
                list.entries[currentIndex].checked = entryCheckbox.checked;
                saveList(list);
            };
            
            // Debounced save for entry text changes
            const debouncedSaveEntry = debounce(async (newText) => {
                const currentIndex = parseInt(li.dataset.entryIndex);
                list.entries[currentIndex].text = newText;
                await saveList(list);
            }, 500);
            
            entryInput.oninput = () => {
                debouncedSaveEntry(entryInput.value);
            };

            const deleteEntryBtn = document.createElement('button');
            deleteEntryBtn.className = 'delete-entry-btn';
            deleteEntryBtn.textContent = 'Delete';
            deleteEntryBtn.onclick = async () => {
                const currentIndex = parseInt(li.dataset.entryIndex);
                
                // Remove from DOM immediately
                li.remove();
                
                // Update data and save in background
                list.entries.splice(currentIndex, 1);
                
                // Update remaining entry indexes
                const listElement = document.querySelector(`[data-list-id="${list.id}"]`);
                updateEntryDataIndexes(listElement, list);
                
                await saveList(list);
            };

            // Make entry draggable
            li.draggable = true;
            li.dataset.entryIndex = entryIdx;
            
            // Entry drag event listeners
            li.addEventListener('dragstart', (e) => {
                e.stopPropagation();
                console.log('Entry dragstart - clearing all data and setting entry data');
                e.dataTransfer.clearData();
                
                // Get the current text value from the input, not from the data array
                const entryInput = li.querySelector('.entry-input');
                const entryCheckbox = li.querySelector('.entry-checkbox');
                const currentText = entryInput ? entryInput.value : (entry.text || entry);
                const currentChecked = entryCheckbox ? entryCheckbox.checked : (entry.checked || false);
                
                const dragData = {
                    entryText: currentText,
                    entryChecked: currentChecked,
                    entryIndex: parseInt(li.dataset.entryIndex),
                    sourceListId: list.id
                };
                e.dataTransfer.setData('application/json', JSON.stringify(dragData));
                e.dataTransfer.setData('text/plain', 'entry');
                console.log('Entry drag data set with text:', currentText, 'Checked:', currentChecked);
                e.dataTransfer.effectAllowed = 'move';
                li.classList.add('dragging');
            });
            
            li.addEventListener('dragend', () => {
                li.classList.remove('dragging');
                // Clean up any lingering drag-over styling when drag ends
                setTimeout(cleanupAllDragStyling, 10);
            });
            
            li.addEventListener('dragover', (e) => {
                const types = Array.from(e.dataTransfer.types);
                if (types.includes('application/json')) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    li.classList.add('drag-over');
                }
            });
            
            li.addEventListener('dragleave', () => {
                li.classList.remove('drag-over');
            });
            
            li.addEventListener('drop', async (e) => {
                const types = Array.from(e.dataTransfer.types);
                if (types.includes('application/json')) {
                    e.preventDefault();
                    e.stopPropagation();
                    li.classList.remove('drag-over');
                    
                    try {
                        const dragData = JSON.parse(e.dataTransfer.getData('application/json'));
                        const sourceListId = dragData.sourceListId;
                        const sourceEntryIdx = dragData.entryIndex;
                        const targetListId = list.id;
                        const targetEntryIdx = parseInt(li.dataset.entryIndex);
                        
                        if (sourceListId === targetListId) {
                            // Same list - reorder within list
                            if (sourceEntryIdx !== targetEntryIdx) {
                                const listElement = document.querySelector(`[data-list-id="${list.id}"]`);
                                await reorderEntries(listElement, list, sourceEntryIdx, targetEntryIdx);
                            }
                        } else {
                            // Different lists - move entry between lists
                            await moveEntryBetweenLists(sourceListId, sourceEntryIdx, targetListId, targetEntryIdx);
                        }
                    } catch (err) {
                        console.error('Error parsing drag data:', err);
                    }
                }
            });

            li.appendChild(entryDragHandle);
            li.appendChild(entryCheckbox);
            li.appendChild(entryInput);
            li.appendChild(deleteEntryBtn);
            return li;
        }

        // Create a complete list element (for optimistic UI updates)
        function createListElement(list) {
            // Ensure entries exists and is an array, and list has an ID
            if (!Array.isArray(list.entries)) {
                list.entries = [];
            } else {
                // Convert string entries to object format if needed
                list.entries = list.entries.map(entry => {
                    if (typeof entry === 'string') {
                        return { text: entry, checked: false };
                    }
                    return entry;
                });
            }
            if (!list.id) list.id = generateListId();

            const listDiv = document.createElement('div');
            listDiv.className = 'list';

            // List header with drag handle, editable title and delete button
            const headerDiv = document.createElement('div');
            headerDiv.className = 'list-header';

            // Add drag handle for lists
            const listDragHandle = document.createElement('span');
            listDragHandle.className = 'drag-handle';
            listDragHandle.innerHTML = '⋮⋮';
            listDragHandle.title = 'Drag to reorder lists';
            listDragHandle.draggable = true;
            
            const titleInput = document.createElement('input');
            titleInput.type = 'text';
            titleInput.value = list.title;
            titleInput.className = 'list-title';
            
            // Debounced save for title changes
            const debouncedSaveTitle = debounce(async (newTitle) => {
                list.title = newTitle;
                await saveList(list);
            }, 500);
            
            titleInput.oninput = () => {
                debouncedSaveTitle(titleInput.value);
            };

            const deleteListBtn = document.createElement('button');
            deleteListBtn.className = 'delete-list-btn';
            deleteListBtn.textContent = 'Delete';
            deleteListBtn.onclick = async () => {
                // Remove from DOM immediately
                listDiv.remove();
                
                // Remove from data and delete from database in background
                const listIndex = listsData.findIndex(l => l.id === list.id);
                if (listIndex !== -1) {
                    listsData.splice(listIndex, 1);
                }
                await deleteList(list.id);
            };

            headerDiv.appendChild(listDragHandle);
            headerDiv.appendChild(titleInput);
            headerDiv.appendChild(deleteListBtn);
            
            // Store list ID for reference
            listDiv.dataset.listId = list.id;
            
            // Drag event listeners for the drag handle
            listDragHandle.addEventListener('dragstart', (e) => {
                console.log('List dragstart - clearing all data and setting list data');
                e.dataTransfer.clearData();
                e.dataTransfer.setData('text/plain', list.id);
                e.dataTransfer.setData('application/x-list', list.id);
                console.log('List drag data set. Types should be:', ['text/plain', 'application/x-list']);
                e.dataTransfer.effectAllowed = 'move';
                listDiv.classList.add('dragging');
            });
            
            listDragHandle.addEventListener('dragend', () => {
                listDiv.classList.remove('dragging');
            });
            
            listDiv.addEventListener('dragover', (e) => {
                const types = Array.from(e.dataTransfer.types);
                if (types.includes('application/x-list')) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    listDiv.classList.add('drag-over');
                }
            });
            
            listDiv.addEventListener('dragleave', (e) => {
                // Only remove drag-over if we're actually leaving the list element
                if (!listDiv.contains(e.relatedTarget)) {
                    listDiv.classList.remove('drag-over');
                }
            });
            
            listDiv.addEventListener('drop', async (e) => {
                const types = Array.from(e.dataTransfer.types);
                console.log('List drop handler triggered. Types:', types, 'Target list:', list.id);
                
                // ONLY process list drops, never entry drops
                if (types.includes('application/x-list') && !types.includes('application/json')) {
                    console.log('Processing as list drop');
                    e.preventDefault();
                    e.stopPropagation(); // Important: stop event from bubbling
                    listDiv.classList.remove('drag-over');
                    
                    const draggedListId = e.dataTransfer.getData('text/plain');
                    const targetListId = list.id;
                    
                    console.log(`Drop detected: dragged=${draggedListId}, target=${targetListId}`);
                    
                    if (draggedListId && draggedListId !== targetListId) {
                        console.log('Calling reorderLists...');
                        await reorderLists(draggedListId, targetListId);
                    } else if (draggedListId === targetListId) {
                        console.log('Same list - no reorder needed');
                    } else {
                        console.log('Invalid draggedListId:', draggedListId);
                    }
                } else {
                    console.log('Ignoring drop - not a valid list drop (has JSON:', types.includes('application/json'), ', has x-list:', types.includes('application/x-list'), ')');
                }
            });

            // Add entry group
            const addEntryGroup = document.createElement('div');
            addEntryGroup.className = 'add-entry-group';

            const addEntryInput = document.createElement('input');
            addEntryInput.type = 'text';
            addEntryInput.className = 'add-entry-input';
            addEntryInput.placeholder = 'Add a new item...';

            const addEntryBtn = document.createElement('button');
            addEntryBtn.className = 'add-entry-btn';
            addEntryBtn.textContent = 'Add';

            // Entries list
            const ul = document.createElement('ul');
            list.entries.forEach((entry, entryIdx) => {
                const li = createEntryElement(list, entry, entryIdx);
                ul.appendChild(li);
            });
            
            // Make the entire list container a drop zone for entries
            ul.addEventListener('dragover', (e) => {
                const types = Array.from(e.dataTransfer.types);
                if (types.includes('application/json')) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    ul.classList.add('drag-over');
                }
            });
            
            ul.addEventListener('dragleave', (e) => {
                if (!ul.contains(e.relatedTarget)) {
                    ul.classList.remove('drag-over');
                }
            });
            
            ul.addEventListener('drop', async (e) => {
                const types = Array.from(e.dataTransfer.types);
                console.log('UL drop handler triggered. Types:', types, 'Target list:', list.id);
                if (types.includes('application/json')) {
                    console.log('Processing as entry drop in UL');
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Immediate cleanup
                    cleanupAllDragStyling();
                    
                    try {
                        const dragData = JSON.parse(e.dataTransfer.getData('application/json'));
                        const sourceListId = dragData.sourceListId;
                        const sourceEntryIdx = dragData.entryIndex;
                        const targetListId = list.id;
                        
                        if (sourceListId !== targetListId) {
                            // Different lists - add to end of target list
                            await moveEntryBetweenLists(sourceListId, sourceEntryIdx, targetListId, list.entries.length);
                        } else {
                            // Same list - move to end of list
                            const listElement = document.querySelector(`[data-list-id="${list.id}"]`);
                            await reorderEntries(listElement, list, sourceEntryIdx, list.entries.length - 1);
                        }
                        
                        // Additional cleanup after operations complete
                        setTimeout(cleanupAllDragStyling, 50);
                        
                    } catch (err) {
                        console.error('Error parsing drag data in list drop:', err);
                    }
                }
            });

            addEntryBtn.onclick = async () => {
                const text = addEntryInput.value.trim();
                if (text === '') return;
                
                // Update data immediately
                const newEntry = { text: text, checked: false };
                list.entries.push(newEntry);
                addEntryInput.value = '';
                
                // Add new entry to DOM immediately
                const newLi = createEntryElement(list, newEntry, list.entries.length - 1);
                ul.appendChild(newLi);
                
                // Save in background
                await saveList(list);
            };
            addEntryInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') addEntryBtn.click();
            });

            addEntryGroup.appendChild(addEntryInput);
            addEntryGroup.appendChild(addEntryBtn);

            listDiv.appendChild(headerDiv);
            listDiv.appendChild(addEntryGroup);
            listDiv.appendChild(ul);
            
            return listDiv;
        }

        async function getLists() {
            console.log('getLists called');
            try {
                // Get the current user
                console.log('Getting current user...');
                const { data: { user }, error: userError } = await supabase.auth.getUser();
                console.log('User data:', { user, userError });
                
                if (userError || !user) {
                    const errorMsg = 'User not authenticated: ' + (userError?.message || 'No user found');
                    console.error(errorMsg);
                    throw new Error(errorMsg);
                }

                console.log('Fetching shopping lists for user:', user.id);
                
                // Get lists only for the current user
                const { data, error, status, statusText } = await supabase
                    .from('shopping_lists')
                    .select('*')
                    .eq('user_id', user.id)  // Filter by current user's ID
                    .order('list_order', { ascending: true, nullsFirst: false })
                    .order('updated_at', { ascending: true });
                
                console.log('Database response:', { 
                    data, 
                    error, 
                    status, 
                    statusText,
                    user_id: user.id
                });
                
                if (error) {
                    console.error('Database error:', error);
                    throw error;
                }
                
                console.log('Raw shopping lists data from database:', data);
                
                // Convert Supabase data to expected format and store in memory
                const processedData = (data || []).map(list => {
                    const processedList = {
                        id: list.id,
                        title: list.title || 'Untitled List',
                        entries: Array.isArray(list.entries) ? list.entries : []
                    };
                    console.log('Processed list:', processedList);
                    return processedList;
                });
                
                console.log('All processed shopping lists:', processedData);
                return processedData;
                
            } catch (err) {
                const errorMsg = 'Error in getLists: ' + (err.message || 'Unknown error');
                console.error(errorMsg, err);
                showError(errorMsg);
                return [];
            }
        }

        // Save a single list by ID - safer than overwriting everything
        async function saveList(list) {
            try {
                if (!list.id) {
                    list.id = generateListId();
                }
                console.log('Saving individual list:', list.id, list);
                
                // Check if list exists (update) or is new (insert)
                const { data: existingList, error: fetchError } = await supabase
                    .from('shopping_lists')
                    .select('id')
                    .eq('id', list.id);
                    
                if (fetchError) {
                    console.error('Error checking for existing list:', fetchError);
                    throw fetchError;
                }
                
                let result;
                if (existingList && existingList.length > 0) {
                    // Update existing list
                    result = await supabase
                        .from('shopping_lists')
                        .update({
                            title: list.title,
                            entries: list.entries,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', list.id);
                } else {
                    // Insert new list - get the next list_order value
                    const { data: maxOrderData } = await supabase
                        .from('shopping_lists')
                        .select('list_order')
                        .order('list_order', { ascending: false })
                        .limit(1);
                    
                    const nextOrder = (maxOrderData && maxOrderData[0] && maxOrderData[0].list_order !== null) 
                        ? maxOrderData[0].list_order + 1 
                        : 0;
                    
                    // Get the current user ID from the auth session
                    const { data: { user } } = await supabase.auth.getUser();
                    if (!user) {
                        throw new Error('User not authenticated');
                    }

                    result = await supabase
                        .from('shopping_lists')
                        .insert({
                            id: list.id,
                            title: list.title,
                            entries: list.entries,
                            list_order: nextOrder,
                            user_id: user.id  // Add the user_id to the new list
                        });
                }
                
                if (result.error) {
                    throw result.error;
                }
                
                console.log('List saved successfully:', list.id);
                return true;
            } catch (err) {
                console.error('Error saving list:', err);
                showError('Error saving list: ' + err.message);
                return false;
            }
        }

        // Delete a single list by ID
        async function deleteList(listId) {
            try {
                console.log('Deleting list:', listId);
                const { error } = await supabase
                    .from('shopping_lists')
                    .delete()
                    .eq('id', listId);
                
                if (error) {
                    throw error;
                }
                
                console.log('List deleted successfully:', listId);
                return true;
            } catch (err) {
                console.error('Error deleting list:', err);
                showError('Error deleting list: ' + err.message);
                return false;
            }
        }

        // Legacy function for compatibility - now saves each list individually
        async function saveLists(lists) {
            try {
                console.log('Saving all lists individually:', lists);
                const savePromises = lists.map(list => saveList(list));
                const results = await Promise.all(savePromises);
                const allSuccessful = results.every(result => result === true);
                if (allSuccessful) {
                    console.log('All lists saved successfully');
                } else {
                    console.warn('Some lists failed to save');
                }
                return allSuccessful;
            } catch (err) {
                console.error('Error saving lists:', err);
                showError('Error saving lists: ' + err.message);
                return false;
            }
        }

        async function renderLists() {
            console.log('renderLists called');
            const listsContainer = document.getElementById('lists-container');
            listsContainer.innerHTML = '';
            const lists = await getLists();
           
            console.log('Lists to render:', lists, 'Length:', lists.length);

            lists.forEach((list) => {
                const listDiv = createListElement(list);
                listsContainer.appendChild(listDiv);
            });
        }

        // Make functions globally available immediately
        window.getLists = getLists;
        window.saveLists = saveLists;
        window.saveList = saveList;
        window.deleteList = deleteList;
        window.renderLists = renderLists;
        window.showError = showError;
        window.generateListId = generateListId;

        // Check authentication and redirect to settings if not authenticated
        async function checkAuth() {
            const { data: { user }, error } = await supabase.auth.getUser();
            if (error || !user) {
                console.log('User not authenticated, redirecting to settings');
                window.location.href = 'settings.html';
                return null;
            }
            return user;
        }

        // Initialize the app with fade-in effect
        (async function init() {
            // First, check if we're already on the settings page to prevent redirect loops
            if (window.location.pathname.endsWith('settings.html')) {
                document.body.classList.add("loaded");
                return;
            }

            // Check authentication first - this will redirect if not authenticated
            const user = await checkAuth();
            if (!user) return; // Redirect already handled by checkAuth
            
            // Only proceed with loading data if we have a valid user
            try {
                await getLists();
                document.body.classList.add("loaded");
            } catch (error) {
                console.error("Error loading data:", error);
                showError('Error loading your shopping lists. Please refresh the page.');
                document.body.classList.add("loaded");
            }
        })();

        // Set up event handlers after functions are available
        document.addEventListener('DOMContentLoaded', () => {
            // Add new list
            document.getElementById('add-list-btn').onclick = async () => {
                const input = document.getElementById('add-list-input');
                const name = input.value.trim() || 'New Shopping List';
                const newList = {
                    id: generateListId(),
                    title: name,
                    entries: []
                };
                
                // Clear input immediately
                input.value = '';
                
                // Add to in-memory data
                listsData.push(newList);
                
                // Add to UI immediately (optimistic update)
                const listsContainer = document.getElementById('lists-container');
                const newListDiv = createListElement(newList);
                listsContainer.appendChild(newListDiv);
                
                // Save in background
                await saveList(newList);
            };

            document.getElementById('add-list-input').addEventListener('keydown', async e => {
                if (e.key === 'Enter') document.getElementById('add-list-btn').click();
            });

            // Initial render
            renderLists();
        });
    </script>
</body>
</html>